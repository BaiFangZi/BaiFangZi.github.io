<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>个人网站1.0</title>
      <link href="/2020/06/19/Project/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%991.0/"/>
      <url>/2020/06/19/Project/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%991.0/</url>
      
        <content type="html"><![CDATA[<h2 id="早些时候用vue写的一个网站"><a href="#早些时候用vue写的一个网站" class="headerlink" title="早些时候用vue写的一个网站"></a>早些时候用vue写的一个网站</h2><p>大三暑假时候在家写的一个网站，第一次写，比较费劲，写的也不是很好，连学带写加百度，陆陆续续用了半个月。</p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p>vue+elementui+axios+express，自己写的@media来进行的响应布局，勉强能支持移动端。<br>用的阿里云的学生服务器，外加一个域名，一共花了不到二百块钱</p><p><a href="http://www.sqrt7.com/projects/myweb/index.html" target="_blank" rel="noopener">链接-http://www.sqrt7.com/projects/myweb/index.html</a><br>刚开始做的时候感觉还不错，但是后来越看网站越嫌弃，感觉做的太难看，对于文章的发布一直也没有什么好的解决思路<br>于是才有了现在的这个博客。</p>]]></content>
      
      
      <categories>
          
          <category> 作品实例 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>elelctron-serialport串口调试工具</title>
      <link href="/2020/06/19/Project/%E5%88%A9%E7%94%A8electron%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95exe%E5%B7%A5%E5%85%B7/"/>
      <url>/2020/06/19/Project/%E5%88%A9%E7%94%A8electron%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95exe%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="一个串口调试工具"><a href="#一个串口调试工具" class="headerlink" title="一个串口调试工具"></a>一个串口调试工具</h2><p>发现每学一门语言就跟串口工具杠上，以前学习C#做过一个，现在实习有让我搞一个<br>这个工具基于electron+serialport，代码编写挺简单，难得是运行环境的搭建，我搭了两天才搭好</p><p><a href="https://github.com/BaiFangZi/electron-serialport" target="_blank" rel="noopener">github地址—https://github.com/BaiFangZi/electron-serialport</a><br><a href="https://github.com/BaiFangZi/electron-vue-serialport" target="_blank" rel="noopener">利用electron-vue进行重新编写—https://github.com/BaiFangZi/electron-vue-serialport</a></p>]]></content>
      
      
      <categories>
          
          <category> 作品实例 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>贪吃蛇小游戏</title>
      <link href="/2020/06/19/Project/%E8%B4%AA%E5%90%83%E8%9B%87/"/>
      <url>/2020/06/19/Project/%E8%B4%AA%E5%90%83%E8%9B%87/</url>
      
        <content type="html"><![CDATA[<h2 id="原生Js编写的小游戏"><a href="#原生Js编写的小游戏" class="headerlink" title="原生Js编写的小游戏"></a>原生Js编写的小游戏</h2><p>操作方法：由↑→↓←四个按键控制，按键长按能实现加速运动，F5或者点击页面“重新开始”按钮重新来时游戏。<br>代码简单，刚学Js的时候拿来练练手<br><a href="http://www.sqrt7.com/projects/snack/index.html" target="_blank" rel="noopener">链接–http://www.sqrt7.com/projects/snack/index.html</a></p><!-- [贪吃蛇](http://localhost:3303/projects/snack/index.html) -->]]></content>
      
      
      <categories>
          
          <category> 作品实例 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>qq音乐官网首页</title>
      <link href="/2020/06/19/Project/qq%E9%9F%B3%E4%B9%90%E5%AE%98%E7%BD%91%E9%A6%96%E9%A1%B5/"/>
      <url>/2020/06/19/Project/qq%E9%9F%B3%E4%B9%90%E5%AE%98%E7%BD%91%E9%A6%96%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="仿照qq音乐官网做的一个静态页面"><a href="#仿照qq音乐官网做的一个静态页面" class="headerlink" title="仿照qq音乐官网做的一个静态页面"></a>仿照qq音乐官网做的一个静态页面</h2><p>学过html和css之后做的一个页面，还有一个淘宝的做了一半就不上传了，页面只支持pc端，移动端打开排版有些地方会<br>错乱。除了轮播图和选项卡的功能没实现、以及尺寸上的偏差外，基本和官网页面一致。</p><p><a href="http://www.sqrt7.com/projects/qqMusic/qqMusic.html" target="_blank" rel="noopener">链接–http://www.sqrt7.com/projects/qqMusic/qqMusic.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 作品实例 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>轮播图</title>
      <link href="/2020/06/19/Project/%E8%BD%AE%E6%92%AD%E5%9B%BE/"/>
      <url>/2020/06/19/Project/%E8%BD%AE%E6%92%AD%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="原生js写的轮播图"><a href="#原生js写的轮播图" class="headerlink" title="原生js写的轮播图"></a>原生js写的轮播图</h2><p>轮播图对于一个网页来说几乎是必不可少的一个特效了，对于页面的美观程度和产品的展示推广都有重要的意义，对于前<br>端开发人员来说就相当于是入门的门槛，于是我就简单写了一个轮播。主要难点就是焦点的遍历添加click属性，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; nav.length + <span class="number">1</span>; i++) &#123;</span><br><span class="line">nav[i - <span class="number">1</span>].index = i;</span><br><span class="line">nav[i - <span class="number">1</span>].addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">imgWrapper.style.left = -(<span class="keyword">this</span>.index - <span class="number">1</span>) * <span class="number">400</span> + <span class="string">"px"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nav.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nav[i].className === <span class="string">"nav active"</span>) &#123;</span><br><span class="line">nav[i].className = <span class="string">"nav"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.className = <span class="string">"nav active"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个是多添加一张图片1放在最后来避免轮播一次出现跳转不连续的情况。<br><img src="https://image-static.segmentfault.com/231/084/2310848987-5a4c54f83d36b_articlex" alt="1"><br><img src="https://image-static.segmentfault.com/293/092/2930922683-5a4c557f0c0c0_articlex" alt="2"></p><p><a href="http://www.sqrt7.com/projects/lunbo/index.html" target="_blank" rel="noopener">链接–http://www.sqrt7.com/projects/lunbo/index.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 作品实例 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在electron中使用serialport的过程</title>
      <link href="/2020/06/19/Problems/%E5%9F%BA%E4%BA%8Eelectron%E7%9A%84%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
      <url>/2020/06/19/Problems/%E5%9F%BA%E4%BA%8Eelectron%E7%9A%84%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="实习的时候师傅给布置的任务"><a href="#实习的时候师傅给布置的任务" class="headerlink" title="实习的时候师傅给布置的任务"></a>实习的时候师傅给布置的任务</h2><h2 id="项目运行所需环境"><a href="#项目运行所需环境" class="headerlink" title="项目运行所需环境"></a>项目运行所需环境</h2><h3 id="1，必须安装nodejs"><a href="#1，必须安装nodejs" class="headerlink" title="1，必须安装nodejs"></a>1，必须安装nodejs</h3><p>附上node下载地址-<a href="http://nodejs.cn/download/" target="_blank" rel="noopener">Nodejs</a></p><p>node安装过程简单， 一直next就行了，我安装的版本是12.16.1，可以在powershell中通过<code>node -v</code>来查看当前版本</p><p><img src="http://www.sqrt7.com/image/%E5%88%A9%E7%94%A8electron%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95exe%E5%B7%A5%E5%85%B7_files/4.jpg" alt=""></p><h3 id="2，安装nod-gyp"><a href="#2，安装nod-gyp" class="headerlink" title="2，安装nod-gyp"></a>2，安装nod-gyp</h3><p>node-gyp是用来编译c++模块的工具，这里用来编译serialport，<br>node-gyp的github文档-<a href="https://github.com/nodejs/node-gyp" target="_blank" rel="noopener">node-gyp文档</a></p><p>全局安装 <code>npm install -g node-gyp</code></p><h4 id="来看这一段来自官方文档的说明"><a href="#来看这一段来自官方文档的说明" class="headerlink" title="来看这一段来自官方文档的说明"></a>来看这一段来自官方文档的说明</h4><p><img src="http://www.sqrt7.com/image/%E5%88%A9%E7%94%A8electron%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95exe%E5%B7%A5%E5%85%B7_files/8.jpg" alt=""></p><h4 id="大致意思就是有两种方案："><a href="#大致意思就是有两种方案：" class="headerlink" title="大致意思就是有两种方案："></a>大致意思就是有两种方案：</h4><p><strong>一种是</strong>下载windows-build-tools,通过命令<code>npm install --global --production windows-build-tools</code>,但是要注意<br>的是必须以管理员的身份启动CMD窗口或者是PowerShell窗口，这种方案下载的东西较少</p><p><strong>还有一种是</strong>要下载Visual Studio和python，这种方案下载的东西就很多了，但是我以前电脑装过VisualStudio并且以后或许会用到<br>所以我选了第二种方案</p><h3 id="3、安装visual-studio-2017"><a href="#3、安装visual-studio-2017" class="headerlink" title="3、安装visual studio 2017"></a>3、安装visual studio 2017</h3><p>附上visual studio下载地址<a href="https://visualstudio.microsoft.com/pl/thank-you-downloading-visual-studio/?sku=Community" target="_blank" rel="noopener">Visual Studio 2017 Community</a><br>安装VS的时候选项如下，要勾选使用c++桌面开发，node-gyp文档上也有提示</p><p><img src="http://www.sqrt7.com/image/%E5%88%A9%E7%94%A8electron%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95exe%E5%B7%A5%E5%85%B7_files/3.jpg" alt=""><br><img src="http://www.sqrt7.com/image/%E5%88%A9%E7%94%A8electron%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95exe%E5%B7%A5%E5%85%B7_files/5.jpg" alt=""></p><p>安装完成之后执行一下命令</p><p><code>npm config set msvs_version 2017</code></p><h3 id="4、安装python2-7"><a href="#4、安装python2-7" class="headerlink" title="4、安装python2.7"></a>4、安装python2.7</h3><p>附上python下载地址-<a href="https://www.python.org/downloads/windows/" target="_blank" rel="noopener">Python2.7x</a></p><p><img src="http://www.sqrt7.com/image/%E5%88%A9%E7%94%A8electron%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95exe%E5%B7%A5%E5%85%B7_files/6.jpg" alt=""><br>python安装注意版本要下载相应的版本 百度了一下说python3.x不支持，为了避免不必要的问题干脆直接装python2.7，<br>具体安装过程记不清了，网上教程很多，大同小异，照着过程安装一遍就行。</p><p>安装完成之后执行命令</p><p><code>npm config set python python2.7</code></p><p>可以在powershell中使用命令<code>python --version</code>来查看安装好的版本<br><img src="http://www.sqrt7.com/image/%E5%88%A9%E7%94%A8electron%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95exe%E5%B7%A5%E5%85%B7_files/7.jpg" alt=""></p><h2 id="项目的安装与使用"><a href="#项目的安装与使用" class="headerlink" title="项目的安装与使用"></a>项目的安装与使用</h2><h3 id="clone到本地"><a href="#clone到本地" class="headerlink" title="clone到本地"></a>clone到本地</h3><p><code>git clone https://github.com/BaiFangZi/electron-serialport.git</code></p><h3 id="切换到项目目录"><a href="#切换到项目目录" class="headerlink" title="切换到项目目录"></a>切换到项目目录</h3><p><code>cd electron-serialport</code></p><h3 id="下载相应的依赖"><a href="#下载相应的依赖" class="headerlink" title="下载相应的依赖"></a>下载相应的依赖</h3><p>npm下载由于网速或者被墙会造成下载失败，推荐使用cnpm<br><img src="http://www.sqrt7.com/image/%E5%88%A9%E7%94%A8electron%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95exe%E5%B7%A5%E5%85%B7_files/1.jpg" alt=""><br><code>npm install</code>或者<code>cnpm install</code></p><p>下载成功后的提示信息<br><img src="http://www.sqrt7.com/image/%E5%88%A9%E7%94%A8electron%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95exe%E5%B7%A5%E5%85%B7_files/2.jpg" alt=""></p><p>由于node版本和electron版本不匹配，所以直接启动会报错，这个时候要执行下面这两个命令来解决这个问题</p><p><code>cd ./node_modules/@serialport/bindings</code></p><p><code>node-gyp rebuild --target=6.0.10 --arch=x64 --dist-url=https://npm.taobao.org/mirrors/atom-shell</code></p><p>然后再返回根目录 <code>cd ../../../../../</code></p><p>启动项目 <code>npm start</code></p><h2 id="项目打包生成exe文件"><a href="#项目打包生成exe文件" class="headerlink" title="项目打包生成exe文件"></a>项目打包生成exe文件</h2><p>我使用的是electron-builder来打包 打包命令</p><p><code>npm run dist</code></p><p>在package.json文件中可以更改build属性来配置相应的打包选项<br><img src="http://www.sqrt7.com/image/%E5%88%A9%E7%94%A8electron%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95exe%E5%B7%A5%E5%85%B7_files/9.jpg" alt=""></p><p>打包过程极有可能被墙，针对这种情况我们可以复制链接然后在浏览器中下载相应的被墙的文件，再手动添加到目录中</p><p>详细过程可以看这篇文章 <a href="https://blog.csdn.net/cctvcqupt/article/details/87904368" target="_blank" rel="noopener">解决下载依赖出错</a><br><img src="http://www.sqrt7.com/image/%E5%88%A9%E7%94%A8electron%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95exe%E5%B7%A5%E5%85%B7_files/10.jpg" alt=""></p><p>build文件夹就是成功打包后的东西，包括安装包等</p><p><a href="https://github.com/BaiFangZi/electron-serialport" target="_blank" rel="noopener">github地址—https://github.com/BaiFangZi/electron-serialport</a><br><a href="https://github.com/BaiFangZi/electron-vue-serialport" target="_blank" rel="noopener">利用electron-vue进行重新编写—https://github.com/BaiFangZi/electron-vue-serialport</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习中遇到的问题及解决方案 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue切换同一路由时页面不刷新</title>
      <link href="/2020/06/19/Problems/vue%E5%88%87%E6%8D%A2%E5%90%8C%E4%B8%80%E8%B7%AF%E7%94%B1%E6%97%B6%E9%A1%B5%E9%9D%A2%E4%B8%8D%E5%88%B7%E6%96%B0/"/>
      <url>/2020/06/19/Problems/vue%E5%88%87%E6%8D%A2%E5%90%8C%E4%B8%80%E8%B7%AF%E7%94%B1%E6%97%B6%E9%A1%B5%E9%9D%A2%E4%B8%8D%E5%88%B7%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="vue跳转同一路由时页不刷新"><a href="#vue跳转同一路由时页不刷新" class="headerlink" title="vue跳转同一路由时页不刷新"></a>vue跳转同一路由时页不刷新</h2><h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><p>利用watch来监听路由，当路由参数改变时就重新获取数据加载页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">$route() &#123;</span><br><span class="line">this.url_params.keyword &#x3D; this.$route.params.keyword;</span><br><span class="line">this.reLoad &#x3D; false;</span><br><span class="line">this.finished &#x3D; false;</span><br><span class="line">&#x2F;&#x2F; 重新加载数据</span><br><span class="line">&#x2F;&#x2F; 将 loading 设置为 true，表示处于加载状态</span><br><span class="line">this.loading &#x3D; true;</span><br><span class="line">this.list &#x3D; [];</span><br><span class="line">this.searchSong();</span><br><span class="line">this.reLoad &#x3D; true;</span><br><span class="line">this.onLoad();</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习中遇到的问题及解决方案 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用BootStrap做一个响应式页面</title>
      <link href="/2020/06/19/Project/Bootstrap%E6%A1%86%E6%9E%B6%E5%B8%83%E5%B1%80%E9%A1%B5%E9%9D%A2/"/>
      <url>/2020/06/19/Project/Bootstrap%E6%A1%86%E6%9E%B6%E5%B8%83%E5%B1%80%E9%A1%B5%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="响应式页面"><a href="#响应式页面" class="headerlink" title="响应式页面"></a>响应式页面</h2><p>学完BootStrap之后仿照它官网上的一个主题案例写的，自适应移动端和pc端，除了一些链接的跳转之外基本实现了案例<br>的效果。</p><p><a href="http://www.sqrt7.com/projects/%E4%B8%AD%E8%93%9D%E7%AD%BE%E8%AF%81/index.html" target="_blank" rel="noopener">链接–(http://www.sqrt7.com/projects/%E4%B8%AD%E8%93%9D%E7%AD%BE%E8%AF%81/index.html)</a></p>]]></content>
      
      
      <categories>
          
          <category> 作品实例 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue生命周期</title>
      <link href="/2020/06/19/Notes/vue/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2020/06/19/Notes/vue/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>token验证</title>
      <link href="/2020/06/19/Notes/node/token%E9%AA%8C%E8%AF%81/"/>
      <url>/2020/06/19/Notes/node/token%E9%AA%8C%E8%AF%81/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stream模块</title>
      <link href="/2020/06/19/Notes/node/stream%E6%A8%A1%E5%9D%97/"/>
      <url>/2020/06/19/Notes/node/stream%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p>node流， 一次性读取指定字节的数据，读取大文件的时候有用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">大文件的拷贝生成</span><br><span class="line">const readStream &#x3D; fs.createReadStream(&#39;xxx.mp4&#39;)</span><br><span class="line">const writeStream &#x3D; fs.createWriteStream(&#39;new_xxx.mp4&#39;)</span><br><span class="line">readStream.pipe(writestream)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js模块化Commonjs</title>
      <link href="/2020/06/19/Notes/node/js%E6%A8%A1%E5%9D%97%E5%8C%96Commonjs/"/>
      <url>/2020/06/19/Notes/node/js%E6%A8%A1%E5%9D%97%E5%8C%96Commonjs/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fs模块</title>
      <link href="/2020/06/19/Notes/node/fs%E6%A8%A1%E5%9D%97/"/>
      <url>/2020/06/19/Notes/node/fs%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p>fs意为file-system，即文件系统，主要用于对文件的操作，比如创建，读取，写入等。</p><h2 id="api（请以官方文档为准）"><a href="#api（请以官方文档为准）" class="headerlink" title="api（请以官方文档为准）"></a>api（请以官方文档为准）</h2><table><thead><tr><th>说明</th><th>异步</th><th>同步</th></tr></thead><tbody><tr><td>打开文件</td><td>fs.open(path[, flags[, mode]], callback)</td><td>fs.opendirSync(path[, options])</td></tr><tr><td>读取文件</td><td>fs.read(fd, buffer, offset, length, position, callback)</td><td></td></tr><tr><td>文件信息</td><td>fs.stat(path[, options], callback)</td><td>fs.statSync(path[, options])</td></tr><tr><td>新建文件</td><td>fs.appendFile(path, data[, options], callback)</td><td>fs.appendFileSync(path, data[, options])</td></tr><tr><td>写入文件</td><td>fs.writeFile(file, data[, options], callback)</td><td>fs.writeFileSync(file, data[, options])</td></tr><tr><td>读取文件</td><td>fs.readFile(path[, options], callback)</td><td>fs.readFileSync(path[, options])</td></tr><tr><td>重命名文件</td><td>fs.rename(oldPath, newPath, callback)</td><td>fs.renameSync(oldPath, newPath)</td></tr><tr><td>关闭文件</td><td>fs.close(fd, callback)</td><td>fs.closeSync(fd)</td></tr><tr><td>截取文件</td><td>fs.ftruncate(fd[, len], callback)</td><td>fs.ftruncateSync(fd[, len])</td></tr><tr><td>删除文件</td><td>fs.unlink(path, callback)</td><td>fs.unlinkSync(path)</td></tr><tr><td>文件存在</td><td>fs.stat() / fs.access()</td><td>fs.existsSync(path)</td></tr><tr><td>监听文件</td><td>fs.watchFile(filename[, options], listener)</td><td></td></tr><tr><td>停止监听</td><td>fs.unwatchFile(filename[, listener])</td><td></td></tr><tr><td>打开大文件</td><td>fs.createReadStream(path[, options])</td><td></td></tr><tr><td>写入大文件</td><td>fs.createWriteStream(path[, options])</td><td></td></tr><tr><td>创建目录</td><td>fs.mkdir(path[, options], callback)</td><td>fs.mkdirSync(path[, options])</td></tr><tr><td>读取目录</td><td>fs.readdir(path[, options], callback)</td><td>fs.readdirSync(path[, options])</td></tr><tr><td>删除目录</td><td>fs.rmdir(path, callback)</td><td>fs.rmdirSync(path)</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>express框架</title>
      <link href="/2020/06/19/Notes/node/express%E6%A1%86%E6%9E%B6/"/>
      <url>/2020/06/19/Notes/node/express%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>创建一个简单服务器 <a href="http://localhost/get_name" target="_blank" rel="noopener">http://localhost/get_name</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const express &#x3D;require(&#39;express&#39;)</span><br><span class="line">const app &#x3D; express()</span><br><span class="line">app.get(&#39;&#x2F;get_name&#39;,function(req,res)&#123;</span><br><span class="line">res.send(&#123;</span><br><span class="line">name:&#39;张三&#39;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.listen(3000,function(err)&#123;</span><br><span class="line">if(err)&#123;</span><br><span class="line">console.log(err)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">console.log(开启服务成功)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对静态文件 css,字体文件等的处理<br><code>app.use(express.static(path))//express.static()方法告诉express框架静态资源文件在哪 默认打开index.html文件</code></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>events模块</title>
      <link href="/2020/06/19/Notes/node/events%E6%A8%A1%E5%9D%97/"/>
      <url>/2020/06/19/Notes/node/events%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p>event.on()注册<br>event.emit()出发<br>event.off()注销</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>modbus</title>
      <link href="/2020/06/19/Notes/modbus/modbus/"/>
      <url>/2020/06/19/Notes/modbus/modbus/</url>
      
        <content type="html"><![CDATA[<h2 id="数字通信"><a href="#数字通信" class="headerlink" title="数字通信"></a>数字通信</h2><h3 id="什么数字通信"><a href="#什么数字通信" class="headerlink" title="什么数字通信"></a>什么数字通信</h3><p>数字通信是只用数字信号（二进制脉冲信号）作为载体来传输信息，或者用数字信号对载波进行数字调制后再传输的通信方式</p><h3 id="数字通信的特点"><a href="#数字通信的特点" class="headerlink" title="数字通信的特点"></a>数字通信的特点</h3><p>抗干扰，抗噪声能力强，可高质量的进行远距离通信<br>数字信号用以加密，信息传输比较安全<br>数字通信设备的产品重复性好，有利于生产以及通信的发展和普及</p><h3 id="数字通信方式"><a href="#数字通信方式" class="headerlink" title="数字通信方式"></a>数字通信方式</h3><p>按传送方式分类：并行、串行<br>按传递送方向分类：单工，半双工，全双工<br>按是否进行调制分类：基带，频带<br>按通信介质分类：双绞线，同轴电缆，光纤</p><h4 id="并行通信"><a href="#并行通信" class="headerlink" title="并行通信"></a>并行通信</h4><p>按字或者字节为整体进行传送，n位必须要n跟线，传输速度快，需要线多，适应于近距离</p><h4 id="串行通信"><a href="#串行通信" class="headerlink" title="串行通信"></a>串行通信</h4><p>二进制位（bit）为单位的数据阐述方式，每次只穿一个bit，需要的信号线少，适用于远距离场合，工业控制多用</p><h5 id="串行通信的同步传送"><a href="#串行通信的同步传送" class="headerlink" title="串行通信的同步传送"></a>串行通信的同步传送</h5><p>同步传送以字节围殴单位，每次传输1-2个同步字符，若干个数据字节（又称数据包）和校验字符，同步传送传输效率高，但是对<br>硬件的要求较高，一般用于高速通信</p><h5 id="串行通信的异步传送"><a href="#串行通信的异步传送" class="headerlink" title="串行通信的异步传送"></a>串行通信的异步传送</h5><p>数据传送过程中，发送方随时传送字符，两个字符直建的时间间隔是不固定的，接收端必须时刻做好接受的准备，传送小路低，但是<br>通信方式简单可靠，成本低，一般用于低速通信，这种通信方式广泛的英语再工业通信控制系统中</p><h4 id="单工通信"><a href="#单工通信" class="headerlink" title="单工通信"></a>单工通信</h4><p>单向通信，</p><h4 id="半双工通信"><a href="#半双工通信" class="headerlink" title="半双工通信"></a>半双工通信</h4><p>双方再一根线上进行通信，双向通信，由于是一根线，所以同一时刻只能执行收或者发</p><h4 id="全双工通信"><a href="#全双工通信" class="headerlink" title="全双工通信"></a>全双工通信</h4><p>可以互相收发 ，没有限制</p><h3 id="通信协议三要素"><a href="#通信协议三要素" class="headerlink" title="通信协议三要素"></a>通信协议三要素</h3><p>通信协议是指通信双方对数据传送控制的一种约定，又称通信规程，约定中包括对通信接口，同步方式，通信格式，<br>传输速度，传送介质，传送步骤，数据格式及控制字符定义等一系列内容做出统一规定，通信双方必须同时遵守</p><h4 id="通信接口标准"><a href="#通信接口标准" class="headerlink" title="通信接口标准"></a>通信接口标准</h4><p>串行数据接口标准：RS232，RS422，R485</p><h4 id="通信格式"><a href="#通信格式" class="headerlink" title="通信格式"></a>通信格式</h4><p>串行异步通信中，双方必须就通信数据传送方式，传送的数据长度，校验方法，和传输速率进行统一设置，这样才能保证通信的正确</p><h4 id="通信数据格式"><a href="#通信数据格式" class="headerlink" title="通信数据格式"></a>通信数据格式</h4><p>必须对信息的传输内容做出规定，例如传输的数据信息帧的结构，设备的站址，功能代码，所发送的数据校验方式，错误检验，<br>信息传输中字符的制式等等，这些信息规定成为听信的数据格式</p><h2 id="通信接口标准-1"><a href="#通信接口标准-1" class="headerlink" title="通信接口标准"></a>通信接口标准</h2><h3 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h3><p>在串行数据接口便准中，最常用的时rs232,rs485,rs422,串行接口标准，两个设备进行通信控制，其通信接口标准必须一致<br>，如果不一致，则需要通过转换变为一致</p><h4 id="电气特性"><a href="#电气特性" class="headerlink" title="电气特性"></a>电气特性</h4><p>逻辑状态的电平，’0’是几伏，’1’是几伏，信号传输方式，传输速率，传输介质，传输距离，还要给出使用的范围，是点对点还是点对多</p><h4 id="机械特性"><a href="#机械特性" class="headerlink" title="机械特性"></a>机械特性</h4><p>用什么连接件，用什么数据线，连接件的引脚定义以及通信时的连接方式</p><h3 id="RS232"><a href="#RS232" class="headerlink" title="RS232"></a>RS232</h3><p>课本217<br><img src="modbus_files/3.jpg" alt=""><br><img src="modbus_files/4.jpg" alt=""><br><img src="modbus_files/5.jpg" alt=""><br><img src="modbus_files/1.jpg" alt=""><br><img src="modbus_files/2.jpg" alt=""></p><h3 id="RS485"><a href="#RS485" class="headerlink" title="RS485"></a>RS485</h3><p>什么是差分信号：幅值相等，相位相反<br><img src="modbus_files/6.jpg" alt=""><br><img src="modbus_files/7.jpg" alt=""><br>RS485接口具有良好的抗噪声干扰性，长的传输距离和多站能力等优点就使其成为首选的串行接口，RS485接口组成的半双工<br>网络，一般只需两根连线，成本低，易实现。RS485接口的这种优秀特点使他在分布式工业控制系统中得到了广泛的应用</p><h3 id="通信接口标准转换"><a href="#通信接口标准转换" class="headerlink" title="通信接口标准转换"></a>通信接口标准转换</h3><p><img src="modbus_files/8.jpg" alt=""></p><h2 id="通信格式与数据格式"><a href="#通信格式与数据格式" class="headerlink" title="通信格式与数据格式"></a>通信格式与数据格式</h2><h3 id="串行异步通信传递"><a href="#串行异步通信传递" class="headerlink" title="串行异步通信传递"></a>串行异步通信传递</h3><p>在数据传送给过程中，发送方可以爱任意时刻传送字符，两个字符之间的时间间隔是不固定的因此首先要解决的问题<br>就是，如何知道开始传送，如何让知道发送完毕，其次，发送字符的位数，第三，如何知道接受到这个字符有没有错<br>这些问题可以通过发送字符的数据格式和规定来解决</p><h3 id="通信格式-1"><a href="#通信格式-1" class="headerlink" title="通信格式"></a>通信格式</h3><p>字符数据格式和波特率</p><h4 id="起止式异步传送字符格式"><a href="#起止式异步传送字符格式" class="headerlink" title="起止式异步传送字符格式"></a>起止式异步传送字符格式</h4><p>起始位：一个字符信息开始 用0表示<br>停止位：一个字符信息结束 用1表示<br>空闲位：两个字符间的空闲，用1表示<br>数据位：一个字符信息的内容，数据为的个数可以7位或者8位<br>检验位：校验数据传送的正确性，亦可以没有<br>        奇校验：一组给定数据中 1 的个数，偶数为1，奇数为0<br>        偶校验：一组给定数据中 1 的个数，偶数为0，奇数为1<br>波特率：衡量数据传输速率，代表每秒钟传送的二进制位数，单位bps</p><h3 id="信息帧和数据格式wei"><a href="#信息帧和数据格式wei" class="headerlink" title="信息帧和数据格式wei"></a>信息帧和数据格式wei</h3><p>一个完整的信息贞称做一帧，也叫数据信息帧，每一帧信息包括数据和必要的控制信息<br>HDLC信息贞结构<br><img src="./modbus_files/9.jpg" alt=""></p><h2 id="modbus通信协议"><a href="#modbus通信协议" class="headerlink" title="modbus通信协议"></a>modbus通信协议</h2><p>一种主从式串行异步半双工通信协议，采用主从式通信结构，可使一个主站对多个从站进行双向通信，主站可单独和从站通信，也可<br>广播式和所有从站通信。</p><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>起始码  地址吗  功能吗 数据区  校验码  停止吗</p><p>功能码常用  ： H03  H06  H10</p><p>ASCII模式通信格式<br>起始位 ：1为<br>数据长度 ：7为  低位先送<br>校验位：1为（有校验）  0为（无校验）<br>停止位：1为（有校验）  2为（无校验）<br>波特率：可选</p><table><thead><tr><th>协议</th><th>起始码</th><th>地址吗</th><th>功能吗</th><th>数据区</th><th>校验吗</th><th>停止吗</th><th>传输效率</th><th>程序处理</th></tr></thead><tbody><tr><td>ASCII</td><td>:（冒号）</td><td>01-1F</td><td>功能吗</td><td>n个字符</td><td>LRC</td><td>CR,LF</td><td>低</td><td>直观，简单，易调试</td></tr></tbody></table><p>LRC算法<br>参与校验的数据：从地址吗到数据区的所有数据<br>算法：相邻2个16进制相加求和<br>检验码：取其和的低8位和补码位校验码(补码是原码取反加一)</p><p>RTU模式通信格式<br>起始位 ：1为<br>数据长度 ：8为  低位先送<br>校验位：1为（有校验）  0为（无校验）<br>停止位：1为（有校验）  2为（无校验）<br>波特率：可选</p><table><thead><tr><th>协议</th><th>起始码</th><th>地址吗</th><th>功能吗</th><th>数据区</th><th>校验吗</th><th>停止吗</th><th>传输效率</th><th>程序处理</th></tr></thead><tbody><tr><td>RTU</td><td>3.5个字符时间的停顿间隔</td><td>01-1F</td><td>功能吗</td><td>n个字符</td><td>CRC</td><td>3.5个字符时间的停顿间隔</td><td>低</td><td>直观，简单，易调试</td></tr></tbody></table><p>crc校验<br><a href="https://blog.csdn.net/qiaobt/article/details/81661345" target="_blank" rel="noopener"></a></p><p>摘要：毕设研究意义，用社么方法研究，<br>百度翻译英语<br>目录：<br>        1绪论<br>        2理论<br>        3自己的设计</p><p>工业总线的介绍<br>设计方法研究<br>modbus功能介绍，传输方式<br>modbus的设计</p><p>从站，采集 驱动，电源</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> modbus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js创建对象的三种方式</title>
      <link href="/2020/06/19/Notes/js/js%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2020/06/19/Notes/js/js%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1，字面量的形式创建："><a href="#1，字面量的形式创建：" class="headerlink" title="1，字面量的形式创建："></a>1，字面量的形式创建：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var per&#x3D;&#123;</span><br><span class="line">name:&quot;qw&quot;,</span><br><span class="line">age:20,</span><br><span class="line">read:function()&#123;</span><br><span class="line">document.write(&quot;qwdad&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">document.write(per.name+per.age);</span><br><span class="line">per.read();</span><br></pre></td></tr></table></figure><h2 id="2，调用系统的构造函数："><a href="#2，调用系统的构造函数：" class="headerlink" title="2，调用系统的构造函数："></a>2，调用系统的构造函数：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj&#x3D;new Object();</span><br><span class="line">obj.name&#x3D;&quot;wew&quot;;</span><br><span class="line">obj.age&#x3D;30;</span><br><span class="line">obj.read&#x3D;function()&#123;</span><br><span class="line">document.write(&quot;read &quot;);</span><br><span class="line">&#125;;</span><br><span class="line">document.write(obj.name+obj.age);</span><br><span class="line">obj.read();</span><br></pre></td></tr></table></figure><h2 id="3-自定义构造函数："><a href="#3-自定义构造函数：" class="headerlink" title="3,自定义构造函数："></a>3,自定义构造函数：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">this.name&#x3D;&quot;22&quot;;</span><br><span class="line">this.age&#x3D;40;</span><br><span class="line">this.read&#x3D;function()&#123;</span><br><span class="line">document.write(&quot;book&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var per&#x3D;new Person();</span><br><span class="line">document.write(per.name+per.age);</span><br><span class="line">per.read();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js的预处理机制</title>
      <link href="/2020/06/19/Notes/js/js%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/06/19/Notes/js/js%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>#qqq</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js的作用域</title>
      <link href="/2020/06/19/Notes/js/js%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2020/06/19/Notes/js/js%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="全局作用域和函数作用域"><a href="#全局作用域和函数作用域" class="headerlink" title="全局作用域和函数作用域"></a>全局作用域和函数作用域</h2><p>ES5只有全局作用域和函数作用域，没有块级作用域，目前ES6通过 let 语句增加了块级作用域这一功能。<br>全局作用域： 变量在全局中都能使用，就是全局变量。<br>函数作用域：函数内部的变量，调用函数才能使用，</p><h2 id="函数作用域的缺点："><a href="#函数作用域的缺点：" class="headerlink" title="函数作用域的缺点："></a>函数作用域的缺点：</h2><h3 id="1，函数内部局部变量会覆盖全局变量"><a href="#1，函数内部局部变量会覆盖全局变量" class="headerlink" title="1，函数内部局部变量会覆盖全局变量"></a>1，函数内部局部变量会覆盖全局变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var tmp &#x3D; new Date();</span><br><span class="line">function f()&#123;</span><br><span class="line">var tmp &#x3D; &quot;hello&quot;; </span><br><span class="line">  console.log(tmp);</span><br><span class="line">&#125; </span><br><span class="line">f(); &#x2F;&#x2F; hello</span><br></pre></td></tr></table></figure><h3 id="2，数据泄露成全局变量。"><a href="#2，数据泄露成全局变量。" class="headerlink" title="2，数据泄露成全局变量。"></a>2，数据泄露成全局变量。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var s &#x3D; &quot;hello&quot;;</span><br><span class="line">for(var i&#x3D;0;i&lt;s.length;i++)&#123;</span><br><span class="line">  console.log(s[i]);</span><br><span class="line">&#125; </span><br><span class="line">console.log(i); &#x2F;&#x2F; 5</span><br><span class="line">在引用了块级作用域之后，使代码块之间不受影响，代码块指大括号之间的内容。</span><br><span class="line">function f1()&#123;</span><br><span class="line">  let n &#x3D; 5;</span><br><span class="line">  if(true)&#123;</span><br><span class="line">    let n &#x3D; 10;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(n); &#x2F;&#x2F; 5</span><br><span class="line">&#125;</span><br><span class="line">外层作用域无法读取内层作用域中的内容</span><br><span class="line">&#123;</span><br><span class="line">    &#123;  let insane &#x3D; &quot;hello&quot;  &#125;</span><br><span class="line">    console.log(insance); &#x2F;&#x2F; 报错</span><br><span class="line">&#125;</span><br><span class="line">内层作用域可以定义与外层定义域相同的变量。</span><br><span class="line">&#123;</span><br><span class="line">    let a &#x3D; &quot;hello&quot;;</span><br><span class="line">    &#123;let a &#x3D; &quot;hello&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中的LHS和RHS</title>
      <link href="/2020/06/19/Notes/js/js%E4%B8%AD%E7%9A%84LHS%E5%92%8CRHS/"/>
      <url>/2020/06/19/Notes/js/js%E4%B8%AD%E7%9A%84LHS%E5%92%8CRHS/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是LHS和RHS"><a href="#什么是LHS和RHS" class="headerlink" title="什么是LHS和RHS"></a>什么是LHS和RHS</h2><p>LHS:对哪个赋值就对哪个进行LHS引用，可以理解为赋值操作的目标。<br>RHS:需要获取哪个变量的值，就对哪个变量的值进行RHS引用，理解为赋值操作的源头。</p><p>一般情况下，左边的需要被赋值，是LHS，右边需要寻找到他的值，是RHS。</p><h2 id="RHS-和LHS的作用："><a href="#RHS-和LHS的作用：" class="headerlink" title="RHS 和LHS的作用："></a>RHS 和LHS的作用：</h2><p>在变量没有声明时查询方式不一样    就是变量前面没有加var ，<br>进行RHS的时候无法找到该变量的值，则会抛出ReferenceError异常<br>进行LHS找不到变量，非严格模式下，会在全局作用域中，创建一个具有该名称的变量，严格模式下，会抛出与RHS类似的异常。</p><p>Reference  译为引用。</p><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line">console.log(a+b);&#x2F;&#x2F;Uncaught ReferenceError: b is not defined      这个地方在RHS的时候找不到b的值，所以报错</span><br><span class="line">b &#x3D; a;</span><br><span class="line">&#125;</span><br><span class="line">foo(2);</span><br></pre></td></tr></table></figure><p>再如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function init(a)&#123;</span><br><span class="line">    b&#x3D;a+3;                 &#x2F;&#x2F;这个地方在执行LHS的时候，在作用域中没有找到该变量，所以自动创建了一个全局变量b， 所以alert(b)输出为5</span><br><span class="line">&#125;</span><br><span class="line">init(2);    </span><br><span class="line">alert(b);&#x2F;&#x2F; 输出  5</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/yangxiaoguai132/p/5064625.html" target="_blank" rel="noopener">参考链接-https://www.cnblogs.com/yangxiaoguai132/p/5064625.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>promise与async、await的使用</title>
      <link href="/2020/06/19/Notes/js/es6%E4%B8%AD%E7%9A%84async%E5%92%8Cawait/"/>
      <url>/2020/06/19/Notes/js/es6%E4%B8%AD%E7%9A%84async%E5%92%8Cawait/</url>
      
        <content type="html"><![CDATA[<h2 id="promise的使用方法"><a href="#promise的使用方法" class="headerlink" title="promise的使用方法"></a>promise的使用方法</h2><h3 id="promise简介"><a href="#promise简介" class="headerlink" title="promise简介"></a>promise简介</h3><p>是异步编程的一种解决方案。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。解决回调函数嵌套过多的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const promise &#x3D;new Promise(function(resolve,reject)&#123;</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">resolve(&#39;执行成功&#39;)</span><br><span class="line">&#125;,3000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(res&#x3D;&gt;&#123;</span><br><span class="line">console.log(res)</span><br><span class="line">&#125;).catch(err&#x3D;&gt;&#123;</span><br><span class="line">console.log(err)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(111)</span><br></pre></td></tr></table></figure><p>等待三秒后输出  ‘执行成功’,也就是说当异步操作完成，即执行resolve或者reject之后，才会执行then中的操作</p><h2 id="async与await"><a href="#async与await" class="headerlink" title="async与await"></a>async与await</h2><p>模拟一下经常出现的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function getData()&#123;</span><br><span class="line">return new Promise(function(resolve,reject)&#123;</span><br><span class="line">setTimeout(function()&#123;  &#x2F;&#x2F;模拟一下请求</span><br><span class="line">resolve(&#39;执行成功&#39;)</span><br><span class="line">&#125;,3000)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">function main()&#123;</span><br><span class="line">let data&#x3D;&#39;&#39;</span><br><span class="line">getData().then(res&#x3D;&gt;&#123;</span><br><span class="line">data&#x3D;res</span><br><span class="line">&#125;)</span><br><span class="line">console.log(data)</span><br><span class="line">console.log(&#39;操作完成&#39;)</span><br><span class="line">setInterval(()&#x3D;&gt;&#123;</span><br><span class="line">console.log(data)</span><br><span class="line">&#125;,1000)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="es6%E4%B8%AD%E7%9A%84async%E5%92%8Cawait_files/2.jpg" alt=""><br>可以看到第一个console.log(data)的结果为空，这不难解释，因为main函数内容顺序执行，当getData()的时候异步操作<br>还未完成，所以继续执行下面的操作。当第三秒的时候才执行resolve()并且成功输出data，这也对应了上面promise所说<br>的‘执行resolve或者reject之后，才会执行then中的操作’既然这样事情就简单了，一直等待请求完成不就完事了。<br>这里更改main函数为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async function main() &#123;</span><br><span class="line">let data</span><br><span class="line">&#x2F;&#x2F; var data &#x3D; await getData()&#x2F;&#x2F;或者</span><br><span class="line"> await getData().then((res)&#x3D;&gt;&#123;</span><br><span class="line"> data&#x3D;res</span><br><span class="line">&#125;)</span><br><span class="line">console.log(data)</span><br><span class="line">console.log(&#39;操作完成&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br><img src="es6%E4%B8%AD%E7%9A%84async%E5%92%8Cawait_files/1.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http基础</title>
      <link href="/2020/06/19/Notes/http/http%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/06/19/Notes/http/http%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="URL-中的特殊符号的含义"><a href="#URL-中的特殊符号的含义" class="headerlink" title="URL 中的特殊符号的含义"></a>URL 中的特殊符号的含义</h2><p>#：<br>代表网页中的某个位置，就像是锚点<br>比如：<a href="http://www.baidu.com/index.html#img" target="_blank" rel="noopener">http://www.baidu.com/index.html#img</a>   这个网址  他代表当前网页  index.html中的  #img这个锚点，#后面不管是什么字符都会被认为是锚点  当我们改变这个#后面的内容时，只会跳转到这个锚点，浏览器不会重新加载这个网页。但是增加浏览器的历史记录</p><p>?:<br>用于动态网站，实现不同的参数值而生成不同的页面或者返回不同的结果，例如 WordPress 的动态链接就是/?p=ID，其中的 p 就表示 post 文章，ID 就表示文章的 ID，从而可以通过文章的 ID 来访问不同的文章。当然我们还常用的就是通过问号+任意参数来实现页面的刷新，从而获得最新的页面或者缓存的刷新。<br>例如：<a href="https://i.leiue.com/avatar/?size=100" target="_blank" rel="noopener">https://i.leiue.com/avatar/?size=100</a> （访问该链接就可以获得泪雪用户中心默认的用户头像，并且其 size 就是图像像素大小，所以就会是一个 100px 的头像显示）</p><p>&amp;：<br>链接符，多个参数用  &amp;  进行连接</p><p>URL  用来表示从因特网上得到的资源位置和获取资源的方式<br>URL一般形式由以下四个部分组成 ：</p><h2 id="URL中参数的含义"><a href="#URL中参数的含义" class="headerlink" title="URL中参数的含义"></a>URL中参数的含义</h2><p>&lt;协议&gt;  ://  &lt;主机&gt;   :  &lt;端口&gt;  /  &lt;路径&gt;<br><strong>URL完整格式：</strong>protocol://hostname[:port]/path/[;parameters][?query]#fragment</p><p>protocol ：所使用的传输协议 最常用的是 http协议</p><p>file 资源是本地计算机上的文件。格式file://</p><p>ftp 通过 FTP访问资源。格式 ftp://</p><p>gopher 通过 Gopher 协议访问该资源。 </p><p>http 通过 HTTP 访问该资源。 格式 http:// </p><p>https 通过安全的 HTTPS 访问该资源。 格式 https://</p><p>mailto 资源为电子邮件地址，通过 SMTP 访问。 格式 mailto:</p><p>MMS 通过 支持MMS（流媒体）协议的播放该资源。（代表软件：Windows Media Player）格式 mms://</p><p>ed2k 通过 支持ed2k（专用下载链接）协议的P2P软件访问该资源。（代表软件：电驴） 格式 ed2k://</p><p>Flashget 通过 支持Flashget:（专用下载链接）协议的P2P软件访问该资源。（代表软件：快车） 格式 flashget://</p><p>thunder 通过 支持thunder（专用下载链接）协议的P2P软件访问该资源。（代表软件：迅雷） 格式 thunder://</p><p>news 通过 NNTP 访问该资源。</p><p>hostname： 主机名   ip地址</p><p>port ：端口号    http协议默认端口号是 80  如果省略 ，则使用默认的端口号</p><p>path ：目录，文件路径</p><p>parameters :参数</p><p>query ：给动态网页传递参数，多个参数用  &amp;   连接</p><p>fragment ：锚点</p><p>例如下面这个URL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.baidu.com&#x2F;s?rsv_bp&#x3D;0&amp;rsv_sug2&#x3D;0&amp;ie&#x3D;utf-8&amp;word&#x3D;url%E5%9C%B0%E5%9D%80%E6%A0%BC%E5%BC%8F</span><br><span class="line">&amp;tn&#x3D;99455684_hao_pg</span><br></pre></td></tr></table></figure><p>协议：https<br>主机名：<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a><br>端口号：默认  80<br>路径：/s<br>参数：rsv_bp=0<br>    rsv_sug2=0<br>ie=utf-8<br>word=url%E5%9C%B0%E5%9D%80%E6%A0%BC%E5%BC%8F<br>tn=99455684_hao_pg</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jquery常见方法</title>
      <link href="/2020/06/19/Notes/jquery/jq%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/"/>
      <url>/2020/06/19/Notes/jquery/jq%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jquery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css清除浮动</title>
      <link href="/2020/06/19/Notes/css/css%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"/>
      <url>/2020/06/19/Notes/css/css%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-为外层元素设置高度"><a href="#1-为外层元素设置高度" class="headerlink" title="1. 为外层元素设置高度"></a>1. 为外层元素设置高度</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;item&quot;&gt;Item&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;item&quot;&gt;Item&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;item&quot;&gt;Item&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">.container &#123;</span><br><span class="line">  height: 200px;</span><br><span class="line">  border: 1px solid red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.item &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 200px;</span><br><span class="line">  background-color: #f60;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-添加一个空的子元素来清除浮动"><a href="#2-添加一个空的子元素来清除浮动" class="headerlink" title="2. 添加一个空的子元素来清除浮动"></a>2. 添加一个空的子元素来清除浮动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;item&quot;&gt;Item&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;item&quot;&gt;Item&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;item&quot;&gt;Item&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;clearfix&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">.container &#123;</span><br><span class="line">  border: 1px solid red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.item &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 200px;</span><br><span class="line">  background-color: #f60;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.clearfix &#123;</span><br><span class="line">  clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-添加伪元素来清除浮动"><a href="#3-添加伪元素来清除浮动" class="headerlink" title="3. 添加伪元素来清除浮动"></a>3. 添加伪元素来清除浮动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;container clearfix&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;item&quot;&gt;Item&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;item&quot;&gt;Item&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;item&quot;&gt;Item&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">.container &#123;</span><br><span class="line">  border: 1px solid red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.item &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 200px;</span><br><span class="line">  background-color: #f60;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.clearfix::after &#123;</span><br><span class="line">  content: &#39;&#39;;</span><br><span class="line">  display: block;</span><br><span class="line">  clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便说一下，伪类和伪元素的区别，伪类的格式：选择器:伪类，例如 li:first-child，a:hover。伪类添加的 CSS 规则仍然作用在选择器所代表的元素上，只不过只有在某种状态下，才会命中该选择器，例如 a:hover，只有在鼠标悬停在 a标签上，才命中选择器。伪元素的格式：选择器::伪元素，例如 p::first-line，div::before。伪元素添加的 CSS 规则不是作用在选择器代表的元素上，而是作用在选择器代表的元素的某个抽象的子元素上，例如 p::first-line，会把段落的第一行抽象成 p 的子元素，然后把 CSS 规则应用在该子元素上。但是在使用伪元素时，所有的浏览器都可以使用一个冒号的形式 选择器:伪元素，但是这样是不规范的。<br>选择器::before 伪元素和 选择器::after 伪元素，会在选择器代表的元素中抽象出一个子元素，该子元素为该选择器代表的元素的 first-child 或 last-child，该子元素的内容由 content 属性指定。</p><h2 id="4-将外层元素设置为-BFC"><a href="#4-将外层元素设置为-BFC" class="headerlink" title="4. 将外层元素设置为 BFC"></a>4. 将外层元素设置为 BFC</h2><p>BFC 可以包含浮动，还可以阻止垂直外边距（margin-top、margin-bottom）折叠。<br>只要元素满足下面任一条件即可触发 BFC 特性<br>body 根元素<br>浮动元素：float 除 none 以外的值<br>绝对定位元素：position (absolute、fixed)<br>display 为 inline-block、table-cells、flex<br>overflow 除了 visible 以外的值 (hidden、auto、scroll)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;container clearfix&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;item&quot;&gt;Item&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;item&quot;&gt;Item&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;item&quot;&gt;Item&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">.container &#123;</span><br><span class="line">  border: 1px solid red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.item &#123;</span><br><span class="line">  float: left;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 200px;</span><br><span class="line">  background-color: #f60;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.clearfix &#123;</span><br><span class="line">  &#x2F;* 这里也可以采取其他方式将容器变为 BFC，只不过 overflow: hidden 对其它元素的影响最小。 *&#x2F;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css选择器</title>
      <link href="/2020/06/19/Notes/css/css%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>/2020/06/19/Notes/css/css%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
